<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tic-Tac-Toe — Unbeatable AI (Minimax)</title>
<style>
  :root{--bg:#0f1724;--card:#0b1220;--accent:#64ffda;--muted:#94a3b8}
  html,body{height:100%;margin:0}
  body{
    display:flex;align-items:center;justify-content:center;
    font-family:Inter,ui-sans-serif,system-ui,Segoe UI, Roboto, "Helvetica Neue", Arial;
    background:linear-gradient(180deg,#071128 0%, #0f1724 100%);
    color:var(--accent);
    padding:24px;
  }
  .app{
    width:min(420px,96vw);
    background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
    border-radius:12px; padding:18px; box-shadow:0 8px 30px rgba(2,6,23,0.6);
    text-align:center;
  }
  h1{margin:6px 0 12px; font-size:1.2rem; color:var(--accent)}
  .info{color:var(--muted); font-size:0.9rem; margin-bottom:12px}
  .board{
    display:grid;
    grid-template-columns:repeat(3,1fr);
    gap:10px;
    margin:10px auto 14px;
  }
  .cell{
    background:rgba(255,255,255,0.02);
    border:1px solid rgba(255,255,255,0.04);
    height:100px; display:flex;align-items:center;justify-content:center;
    font-size:2.4rem; cursor:pointer; user-select:none; border-radius:8px;
    transition:transform .08s ease, background .12s;
  }
  .cell:active{transform:scale(.98)}
  .cell.disabled{cursor:not-allowed; opacity:.7}
  .controls{display:flex;gap:8px;justify-content:center;flex-wrap:wrap}
  button{
    background:transparent;border:1px solid rgba(255,255,255,0.06); padding:8px 12px;border-radius:8px;
    color:var(--accent); cursor:pointer; font-weight:600;
  }
  button.secondary{color:var(--muted)}
  .status{margin-top:12px; font-weight:700}
  .small{font-size:.85rem;color:var(--muted); margin-top:6px}
  @media (max-width:420px){ .cell{height:80px; font-size:2rem} }
</style>
</head>
<body>
  <div class="app" role="application" aria-label="Tic Tac Toe">
    <h1>Tic-Tac-Toe — Unbeatable AI</h1>
    <div class="info">You play <strong>X</strong>. AI plays <strong>O</strong>. X goes first.</div>

    <div id="board" class="board" aria-live="polite" aria-label="Game board"></div>

    <div class="controls">
      <button id="restart">Restart</button>
      <button id="swap" class="secondary">Swap: Play as O (AI starts)</button>
    </div>

    <div id="status" class="status"></div>
    <div id="sub" class="small">Minimax AI — unbeatable. Click a cell to play.</div>
  </div>

<script>
/*
  Simple browser Tic-Tac-Toe with Minimax AI
  - Board positions are 0..8 (row-major)
  - Human can choose to be X (default) or O (swap button)
  - Minimax returns the optimal move; depth used to prefer faster wins
*/

const WIN_PATTERNS = [
  [0,1,2],[3,4,5],[6,7,8],
  [0,3,6],[1,4,7],[2,5,8],
  [0,4,8],[2,4,6]
];

const boardEl = document.getElementById('board');
const statusEl = document.getElementById('status');
const restartBtn = document.getElementById('restart');
const swapBtn = document.getElementById('swap');

let board;           // array of 'X','O', or null
let human = 'X';
let ai = 'O';
let currentPlayer;   // 'X' or 'O'
let running = false;

function init() {
  board = Array(9).fill(null);
  boardEl.innerHTML = '';
  for (let i=0;i<9;i++){
    const c = document.createElement('div');
    c.className = 'cell';
    c.dataset.index = i;
    c.tabIndex = 0;
    c.setAttribute('role','button');
    c.setAttribute('aria-label', `cell ${i+1}`);
    c.addEventListener('click', onCellClick);
    c.addEventListener('keydown', e => { if (e.key === 'Enter' || e.key === ' ') onCellClick(e); });
    boardEl.appendChild(c);
  }
  currentPlayer = 'X'; // X always moves first by rules
  running = true;
  statusEl.textContent = `Your turn (${human})`;
  // If human chose O, AI must start
  if (human === 'O') {
    statusEl.textContent = 'AI is thinking...';
    // make AI start after tiny delay so UI updates
    setTimeout(() => { aiMove(); }, 200);
  }
}

function onCellClick(e){
  if (!running) return;
  const idx = Number(e.currentTarget.dataset.index);
  if (board[idx]) return; // occupied
  // If it's human's turn
  if (currentPlayer === human) {
    makeMove(idx, human);
    // after human move, check and possibly allow AI
    if (running) {
      statusEl.textContent = 'AI is thinking...';
      setTimeout(() => aiMove(), 120); // slight delay to feel natural
    }
  }
}

function makeMove(idx, player){
  board[idx] = player;
  render();
  const r = checkWinner(board);
  if (r) {
    endGame(r);
    return;
  }
  // switch player
  currentPlayer = (player === 'X') ? 'O' : 'X';
  if (currentPlayer === human) {
    statusEl.textContent = `Your turn (${human})`;
  } else {
    statusEl.textContent = `AI's turn (${ai})`;
  }
}

function render(){
  const cells = boardEl.children;
  for (let i=0;i<9;i++){
    cells[i].textContent = board[i] || '';
    cells[i].classList.toggle('disabled', !!board[i] || !running);
  }
}

function checkWinner(bd){
  // returns {winner: 'X'/'O', line: [...] } or {tie:true} or null
  for (const pat of WIN_PATTERNS) {
    const [a,b,c] = pat;
    if (bd[a] && bd[a] === bd[b] && bd[a] === bd[c]) {
      return { winner: bd[a], line: pat };
    }
  }
  if (bd.every(cell => cell !== null)) return { tie: true };
  return null;
}

function endGame(result) {
  running = false;
  if (result.tie) {
    statusEl.textContent = "It's a tie!";
  } else {
    const who = result.winner;
    if (who === human) {
      statusEl.textContent = `You win! (${who}) — impossible vs perfect AI unless you started as O and AI made a mistake`;
    } else {
      statusEl.textContent = `AI wins (${who}).`;
    }
    // optionally highlight the line
    if (result.line) {
      for (const i of result.line) boardEl.children[i].style.background = 'linear-gradient(90deg, rgba(100,255,218,0.08), rgba(100,255,218,0.02))';
    }
  }
  render();
}

/* Minimax algorithm */
function aiMove(){
  if (!running) return;
  // compute best move for ai on current board
  const best = minimax(board.slice(), ai, 0);
  if (best.move !== undefined) {
    makeMove(best.move, ai);
  } else {
    // no moves? should be tie
    const r = checkWinner(board);
    if (r) endGame(r);
  }
}

/*
  minimax(boardState, player, depth)
  returns: {score: number, move: index}
  Scoring convention:
    +10 - depth for AI win
    -10 + depth for Human win
    0 for tie
*/
function minimax(bd, player, depth) {
  const outcome = checkWinner(bd);
  if (outcome) {
    if (outcome.tie) return { score: 0 };
    return { score: (outcome.winner === ai) ? (10 - depth) : (-10 + depth) };
  }

  const moves = []; // {move, score}
  for (let i=0;i<9;i++){
    if (!bd[i]) {
      bd[i] = player;
      const next = minimax(bd, player === 'X' ? 'O' : 'X', depth + 1);
      moves.push({ move: i, score: next.score });
      bd[i] = null;
    }
  }

  // choose best move depending on player
  if (player === ai) {
    // maximize
    let best = moves[0];
    for (const m of moves) if (m.score > best.score) best = m;
    return best;
  } else {
    // minimize
    let best = moves[0];
    for (const m of moves) if (m.score < best.score) best = m;
    return best;
  }
}

/* Controls */
restartBtn.addEventListener('click', () => {
  // reset any highlight backgrounds
  for (const c of boardEl.children) c.style.background = '';
  init();
});

swapBtn.addEventListener('click', () => {
  // toggle human side
  human = (human === 'X') ? 'O' : 'X';
  ai = (human === 'X') ? 'O' : 'X';
  swapBtn.textContent = human === 'X' ? 'Swap: Play as O (AI starts)' : 'Swap: Play as X (You start)';
  // reset highlights
  for (const c of boardEl.children) c.style.background = '';
  init();
});

/* start */
init();
</script>
</body>
</html>
